<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixelation Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            max-width: 1200px;
            width: 100%;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
            align-items: start;
        }

        .section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .section h2 {
            color: #333;
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 0.95em;
        }

        input[type="file"],
        select,
        input[type="number"],
        input[type="range"] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="file"]:focus,
        select:focus,
        input[type="number"]:focus,
        input[type="range"]:focus {
            outline: none;
            border-color: #667eea;
        }

        input[type="range"] {
            height: 6px;
            padding: 0;
            cursor: pointer;
        }

        .range-value {
            color: #667eea;
            font-weight: 600;
            font-size: 0.9em;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 120px;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
            border: 2px solid #ddd;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #e0e0e0;
        }

        .btn-danger {
            background: #ff6b6b;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #ee5a52;
        }

        .preview-container {
            background: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            position: relative;
        }

        .image-holder {
            position: relative;
            max-width: 100%;
            max-height: 640px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        img#sourceImage {
            max-width: 100%;
            max-height: 640px;
            display: none;
        }

        canvas#outputCanvas {
            border: 2px solid #ddd;
            border-radius: 6px;
            width: 512px;
            height: 512px;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .placeholder {
            color: #999;
            text-align: center;
            padding: 40px 20px;
        }

        .placeholder svg {
            width: 80px;
            height: 80px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .palette-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .palette-option {
            padding: 12px;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            background: #f9f9f9;
            text-align: center;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 0.9em;
            color: #555;
        }

        .palette-option:hover {
            border-color: #667eea;
            background: #f0f0f0;
        }

        .palette-option.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .palette-preview {
            display: flex;
            gap: 3px;
            margin-top: 8px;
            height: 20px;
            border-radius: 3px;
            overflow: hidden;
        }

        .palette-color {
            flex: 1;
        }

        /* notification styles removed */

        .version-footer {
            position: fixed;
            bottom: 10px;
            right: 15px;
            font-size: 0.8em;
            color: #999;
            z-index: 1000;
        }

        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 2em;
            }

            .button-group {
                flex-direction: column;
            }

            button {
                min-width: auto;
            }
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-container input[type="range"] {
            flex: 1;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }

        .info-item {
            background: #f9f9f9;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #eee;
        }

        .info-item strong {
            display: block;
            color: #333;
            margin-bottom: 4px;
        }

        .crop-overlay {
            position: absolute;
            border: 2px dashed #667eea;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            cursor: move;
            display: none;
            z-index: 10;
        }

        .crop-overlay.active {
            display: block;
        }

        .crop-resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #667eea;
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
            display: none;
            z-index: 11;
        }

        .crop-overlay.active .crop-resize-handle {
            display: block;
        }

        .crop-resize-handle.se {
            bottom: -8px;
            right: -8px;
        }

        .crop-mode-active {
            display: flex !important;
            flex-direction: column;
            gap: 10px;
        }

        .crop-controls {
            display: none;
            background: #f9f9f9;
            border-radius: 6px;
            padding: 15px;
            border: 2px solid #667eea;
        }

        .crop-controls.active {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .crop-dimension-input {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .crop-dimension-input label {
            font-size: 0.85em;
            font-weight: 600;
        }

        .crop-dimension-input input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .crop-button-group {
            grid-column: 1 / -1;
            display: flex;
            gap: 10px;
        }

        .crop-button-group button {
            flex: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ¨ Pixelation Tool</h1>
            <p>Transform your images into pixel art with customizable palettes and effects</p>
        </div>

        <div class="content">
            <!-- Left Panel: Controls -->
            <div class="section">
                <h2>Controls</h2>

                <div class="control-group">
                    <label for="imageUpload">Upload Image</label>
                    <input type="file" id="imageUpload" accept="image/*">
                </div>

                <div class="control-group">
                    <label>Color Palette</label>
                    <div class="palette-grid" id="paletteGrid"></div>
                </div>

                <div class="control-group">
                    <label for="pixelScale">Pixel Scale</label>
                    <div class="slider-container">
                        <input type="range" id="pixelScale" min="1" max="20" value="1">
                        <span class="range-value"><span id="scaleValue">1</span>px</span>
                    </div>
                </div>

                <div class="control-group">
                    <label for="outputResolution">Output Resolution</label>
                    <select id="outputResolution">
                        <option value="">Auto (match input)</option>
                        <option value="128x128">128 Ã— 128</option>
                        <option value="64x64">64 Ã— 64</option>
                        <option value="32x32">32 Ã— 32</option>
                        <option value="16x16">16 Ã— 16</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Cropping</label>
                    <button class="btn-secondary" id="cropToggleBtn" disabled>Enable Crop Tool</button>
                    <div class="crop-controls" id="cropControls">
                        <div class="crop-dimension-input">
                            <label for="cropSize">Square Size (px)</label>
                            <input type="number" id="cropSize" min="10" value="256">
                        </div>
                        <div class="crop-dimension-input">
                            <label for="cropX">X Position</label>
                            <input type="number" id="cropX" min="0" value="0">
                        </div>
                        <div class="crop-dimension-input">
                            <label for="cropY">Y Position</label>
                            <input type="number" id="cropY" min="0" value="0">
                        </div>
                        <div class="crop-dimension-input">
                            <label for="cropReset">Actions</label>
                            <div style="display: flex; gap: 5px;">
                                <button class="btn-secondary" id="cropApplyBtn" style="flex: 1; padding: 8px;">Apply</button>
                                <button class="btn-danger" id="cropCancelBtn" style="flex: 1; padding: 8px;">Cancel</button>
                            </div>
                        </div>
                    </div>
                </div>



                <div class="control-group">
                    <label>Actions</label>
                    <div class="button-group">
                        <button class="btn-primary" id="downloadBtn" disabled>Download</button>
                        <button class="btn-secondary" id="undoBtn" disabled>Undo</button>
                        <button class="btn-secondary" id="revertBtn" disabled>Revert</button>
                        <button class="btn-danger" id="resetBtn">Reset</button>
                    </div>
                </div>

                <!-- notifications removed -->
            </div>

            <!-- Right Panel: Preview -->
            <div class="section">
                <h2>Preview</h2>
                <div class="preview-container" id="previewContainer">
                    <img id="sourceImage" alt="Source Image">
                    <canvas id="outputCanvas"></canvas>
                    <div class="crop-overlay" id="cropOverlay">
                        <div class="crop-resize-handle se"></div>
                    </div>
                    <div class="placeholder" id="placeholder">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                        </svg>
                        <p>Upload an image to get started</p>
                    </div>
                </div>

                <div class="info-grid" id="infoGrid" style="display: none;">
                    <div class="info-item">
                        <strong>Dimensions:</strong>
                        <span id="imageDims">-</span>
                    </div>
                    <div class="info-item">
                        <strong>Palette:</strong>
                        <span id="paletteInfo">PICO-8</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="version-footer">v1.1</div>

    <!-- Pixelation API Script -->
    <script>
        /* Pixelation API - client-side JavaScript */
        (function(global){
         function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
         function rgbToHex(r,g,b){ return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }
         function hexToRgb(hex){
         hex = hex.replace('#','');
         if (hex.length===3) hex = hex.split('').map(c=>c+c).join('');
         const num = parseInt(hex,16);
         return [ (num>>16)&255, (num>>8)&255, num&255 ];
         }
         function nearestColor(r,g,b,palette){
         let best=[0,0,0], bestDist=Infinity;
         for(const c of palette){
         const pr=c[0], pg=c[1], pb=c[2];
         const dr=r-pr, dg=g-pg, db=b-pb;
         const d=dr*dr+dg*dg+db*db;
         if(d<bestDist){ bestDist=d; best=[pr,pg,pb]; }
         }
         return best;
         }

         const COMMON_PALETTES = {
         // Popular palettes
         "Greyscale": Array.from({length:16},(_,i)=>{ const v=Math.round(i*255/15); return [v,v,v]; }),
         "NES": [[0,0,0],[124,124,124],[0,0,252],[0,0,188],[68,40,188],[148,0,132],[168,0,32],[168,16,0],[136,20,0],[80,48,0],[0,120,0],[0,104,0],[0,88,0],[0,64,88],[0,0,0],[0,0,0]],
         "GameBoy": [[15,56,15],[48,98,48],[139,172,15],[155,188,15]],
         "C64": [[0,0,0],[255,255,255],[104,55,43],[112,164,178],[111,61,134],[88,141,67],[53,40,121],[184,199,111],[111,79,37],[67,57,0],[154,103,89],[68,68,68],[108,108,108],[154,154,154],[190,190,190],[255,255,255]],
         "PICO-8": [[0,0,0],[29,43,83],[126,37,83],[0,135,81],[171,82,54],[95,87,79],[194,195,199],[255,241,232],[255,0,77],[255,163,0],[255,236,39],[0,228,54],[41,173,255],[131,118,156],[255,119,168],[255,204,170]],
         "SNES": [[0,0,0],[34,34,136],[68,68,255],[0,102,153],[0,136,85],[0,170,51],[85,170,0],[170,170,51],[170,136,0],[170,68,0],[170,34,34],[170,68,85],[170,102,170],[136,102,136],[255,255,255],[204,204,204]],
         "Web Safe": (function(){
         const vals=[0,51,102,153,204,255], out=[]; for(const r of vals){ for(const g of vals){ for(const b of vals){ out.push([r,g,b]); } } } return out;
         })()
         };

         const COMMON_RESOLUTIONS = [ [128,128],[64,64],[32,32],[16,16] ];

         function Pixelation(fromImg, toCanvas){
         this.fromImg = fromImg || null;
         this.toCanvas = toCanvas || null;
         this.ctx = (this.toCanvas ? this.toCanvas.getContext('2d') : null);
         this.palette = COMMON_PALETTES['PICO-8'];
         this.scale =4; // default pixel scale
         this.maxWidth = null;
         this.maxHeight = null;
         if (this.fromImg) this.hideFromImg();
         }

         // Draw the source image scaled to the CURRENT canvas size
         Pixelation.prototype.draw = function(){
         if(!this.fromImg || !this.toCanvas) return this;
         const srcW = this.fromImg.naturalWidth || this.fromImg.width;
         const srcH = this.fromImg.naturalHeight || this.fromImg.height;
         const dstW = this.toCanvas.width;
         const dstH = this.toCanvas.height;
         this.ctx = this.toCanvas.getContext('2d');
         this.ctx.imageSmoothingEnabled = false;
         // Fill canvas with scaled image to match selected output resolution
         this.ctx.clearRect(0,0,dstW,dstH);
         this.ctx.drawImage(this.fromImg,0,0, srcW, srcH,0,0, dstW, dstH);
         return this;
         };

         Pixelation.prototype.hideFromImg = function(){
         if(this.fromImg){ this.fromImg.style.display = 'none'; }
         return this;
         };

         Pixelation.prototype.setDrawFrom = function(elem){ this.fromImg = elem; return this; };
         Pixelation.prototype.setDrawTo = function(elem){ this.toCanvas = elem; this.ctx = elem.getContext('2d'); return this; };
         Pixelation.prototype.setFromImgSource = function(src){ if(this.fromImg){ this.fromImg.src = src; } return this; };
         Pixelation.prototype.setpalette = function(arr){
         if(Array.isArray(arr) && arr.every(c=>Array.isArray(c) && c.length===3)){
         this.palette = arr.map(c=>[clamp(c[0],0,255),clamp(c[1],0,255),clamp(c[2],0,255)]);
         }
         return this;
         };
         Pixelation.prototype.getpalette = function(){ return this.palette.slice(); };
         Pixelation.prototype.setMaxWidth = function(v){ this.maxWidth = (typeof v==='number'&&v>0)?v:null; return this; };
         Pixelation.prototype.setMaxHeight = function(v){ this.maxHeight = (typeof v==='number'&&v>0)?v:null; return this; };
         Pixelation.prototype.setScale = function(v){ this.scale = clamp(Math.round(v),1,50); return this; };

         Pixelation.prototype.convertGrayscale = function(){
         if(!this.ctx) return this;
         const w=this.toCanvas.width, h=this.toCanvas.height;
         const imgData=this.ctx.getImageData(0,0,w,h);
         const d=imgData.data;
         for(let i=0;i<d.length;i+=4){
         const r=d[i], g=d[i+1], b=d[i+2];
         const y=Math.round(0.299*r+0.587*g+0.114*b);
         d[i]=d[i+1]=d[i+2]=y;
         }
         this.ctx.putImageData(imgData,0,0);
         return this;
         };

         Pixelation.prototype.convertpalette = function(){
         if(!this.ctx) return this;
         const w=this.toCanvas.width, h=this.toCanvas.height;
         const imgData=this.ctx.getImageData(0,0,w,h);
         const d=imgData.data, p=this.palette;
         for(let i=0;i<d.length;i+=4){
         const n = nearestColor(d[i], d[i+1], d[i+2], p);
         d[i]=n[0]; d[i+1]=n[1]; d[i+2]=n[2];
         }
         this.ctx.putImageData(imgData,0,0);
         return this;
         };

         Pixelation.prototype.resizeImage = function(){
         if(!this.ctx) return this;
         const w=this.toCanvas.width, h=this.toCanvas.height;
         let targetW=w, targetH=h;
         if(this.maxHeight && h>this.maxHeight){
         const ratio = this.maxHeight/h; targetH=this.maxHeight; targetW=Math.round(w*ratio);
         } else if(this.maxWidth && w>this.maxWidth){
         const ratio = this.maxWidth/w; targetW=this.maxWidth; targetH=Math.round(h*ratio);
         }
         if(targetW===w && targetH===h) return this;
         const temp=document.createElement('canvas'); temp.width=targetW; temp.height=targetH;
         const tctx=temp.getContext('2d'); tctx.imageSmoothingEnabled=false;
         tctx.drawImage(this.toCanvas,0,0,w,h,0,0,targetW,targetH);
         this.toCanvas.width=targetW; this.toCanvas.height=targetH;
         this.ctx=this.toCanvas.getContext('2d'); this.ctx.imageSmoothingEnabled=false;
         this.ctx.drawImage(temp,0,0);
         return this;
         };

         Pixelation.prototype.pixelate = function(){
         if(!this.ctx) return this;
         const w=this.toCanvas.width, h=this.toCanvas.height, s=this.scale;
         const srcData=this.ctx.getImageData(0,0,w,h);
         const dest=this.ctx; dest.clearRect(0,0,w,h);
         dest.imageSmoothingEnabled=false;
         for(let y=0; y<h; y+=s){
         for(let x=0; x<w; x+=s){
         const idx=((y*w)+x)*4;
         const r=srcData.data[idx], g=srcData.data[idx+1], b=srcData.data[idx+2], a=srcData.data[idx+3];
         dest.fillStyle = `rgba(${r},${g},${b},${a/255})`;
         dest.fillRect(x,y,s,s);
         }
         }
         return this;
         };

         Pixelation.prototype.saveImage = function(){
         if(!this.toCanvas) return this;
         // Prefer toBlob for better compatibility and correctness
         if (this.toCanvas.toBlob) {
         this.toCanvas.toBlob((blob)=>{
         if(!blob) return;
         const url = URL.createObjectURL(blob);
         const link = document.createElement('a');
         link.href = url;
         link.download = 'pixelation.png';
         document.body.appendChild(link);
         link.click();
         document.body.removeChild(link);
         setTimeout(()=>URL.revokeObjectURL(url),1000);
         }, 'image/png');
         } else {
         const dataUrl = this.toCanvas.toDataURL('image/png');
         const link=document.createElement('a');
         link.download = 'pixelation.png';
         link.href = dataUrl;
         link.click();
         }
         return this;
         };

         // helpers exposed
         Pixelation.Common = { Palettes: COMMON_PALETTES, Resolutions: COMMON_RESOLUTIONS, rgbToHex, hexToRgb };

         global.Pixelation = Pixelation;
        })(window);
    </script>

    <!-- Application Logic -->
    <script>
        const elements = {
            imageUpload: document.getElementById('imageUpload'),
            sourceImage: document.getElementById('sourceImage'),
            outputCanvas: document.getElementById('outputCanvas'),
            downloadBtn: document.getElementById('downloadBtn'),
            resetBtn: document.getElementById('resetBtn'),

            pixelScale: document.getElementById('pixelScale'),
            scaleValue: document.getElementById('scaleValue'),
            outputResolution: document.getElementById('outputResolution'),
            placeholder: document.getElementById('placeholder'),
            paletteGrid: document.getElementById('paletteGrid'),
            infoGrid: document.getElementById('infoGrid'),
            imageDims: document.getElementById('imageDims'),
            paletteInfo: document.getElementById('paletteInfo'),
            previewContainer: document.getElementById('previewContainer'),
            cropToggleBtn: document.getElementById('cropToggleBtn'),
            cropControls: document.getElementById('cropControls'),
            cropOverlay: document.getElementById('cropOverlay'),
            cropSize: document.getElementById('cropSize'),
            cropX: document.getElementById('cropX'),
            cropY: document.getElementById('cropY'),
            cropApplyBtn: document.getElementById('cropApplyBtn'),
            cropCancelBtn: document.getElementById('cropCancelBtn')
            ,undoBtn: document.getElementById('undoBtn')
            ,revertBtn: document.getElementById('revertBtn')
        };

        let pixelation = null;
        let currentPalette = 'Image Default';
        let cropMode = false;
        let isCropped = false;
        let croppedImageData = null;
        let history = [];
        let currentImageData = null;
        let backupBeforeCrop = null;
        let cropState = {
            size: 256,
            x: 0,
            y: 0,
            isDragging: false,
            isResizing: false,
            dragStartX: 0,
            dragStartY: 0,
            originalCropX: 0,
            originalCropY: 0
        };
        let originalImageData = null;

        // notifications removed

        function initPaletteGrid() {
            elements.paletteGrid.innerHTML = '';
            
            // Add 'Image Default' option first (no color preview)
            const defaultBtn = document.createElement('div');
            defaultBtn.className = `palette-option ${currentPalette === 'Image Default' ? 'active' : ''}`;
            defaultBtn.textContent = 'Image Default';
            defaultBtn.addEventListener('click', () => selectPalette('Image Default'));
            elements.paletteGrid.appendChild(defaultBtn);
            
            Object.keys(Pixelation.Common.Palettes).forEach(name => {
                const palette = Pixelation.Common.Palettes[name];
                const btn = document.createElement('div');
                btn.className = `palette-option ${name === currentPalette ? 'active' : ''}`;
                btn.textContent = name;

                const preview = document.createElement('div');
                preview.className = 'palette-preview';
                const step = Math.ceil(palette.length / 5);
                for (let i = 0; i < palette.length; i += step) {
                    const [r, g, b] = palette[i];
                    const color = document.createElement('div');
                    color.className = 'palette-color';
                    color.style.backgroundColor = `rgb(${r},${g},${b})`;
                    preview.appendChild(color);
                }

                btn.appendChild(preview);
                btn.addEventListener('click', () => selectPalette(name));
                elements.paletteGrid.appendChild(btn);
            });
        }

        function selectPalette(name) {
            currentPalette = name;
            document.querySelectorAll('.palette-option').forEach(el => {
                el.classList.toggle('active', el.textContent === name);
            });
            
            // Auto-apply palette effect when selected
            if (!pixelation) return;
            
            try {
                if (!currentImageData) return;
                
                if (name === 'Image Default') {
                    // For Image Default, just update the label without applying palette effect
                    elements.paletteInfo.textContent = 'Image Default';
                } else {
                    // Apply palette effect
                    pushHistory();
                    const img = new Image();
                    img.onload = () => {
                        elements.outputCanvas.width = img.width;
                        elements.outputCanvas.height = img.height;
                        const ctx = elements.outputCanvas.getContext('2d');
                        ctx.imageSmoothingEnabled = false;
                        ctx.clearRect(0,0,elements.outputCanvas.width,elements.outputCanvas.height);
                        ctx.drawImage(img, 0, 0);
                        pixelation.setDrawTo(elements.outputCanvas);
                        pixelation.setpalette(Pixelation.Common.Palettes[name]);
                        pixelation.convertpalette();
                        currentImageData = elements.outputCanvas.toDataURL();
                        // Update preview display size after applying palette
                        setCanvasDisplaySize();
                        isCropped = currentImageData !== originalImageData;
                        croppedImageData = isCropped ? currentImageData : null;
                        elements.paletteInfo.textContent = name;
                        elements.undoBtn.disabled = history.length === 0;
                        elements.revertBtn.disabled = (currentImageData === originalImageData);
                    };
                    img.src = currentImageData;
                }
            } catch (error) {
                console.error(error);
            }
        }

        // History and state helpers
        function pushHistory() {
            if (!currentImageData) return;
            history.push(currentImageData);
            if (history.length > 30) history.shift();
            elements.undoBtn.disabled = history.length === 0;
            elements.revertBtn.disabled = (currentImageData === originalImageData);
        }

        function restoreFromDataURL(dataURL, updateCurrent = true) {
            if (!dataURL) return;
            const img = new Image();
            img.onload = () => {
                elements.outputCanvas.width = img.width;
                elements.outputCanvas.height = img.height;
                const ctx = elements.outputCanvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0,0,elements.outputCanvas.width, elements.outputCanvas.height);
                ctx.drawImage(img, 0, 0);
                // Ensure preview displays at constrained size while preserving aspect ratio
                setCanvasDisplaySize();
                if (updateCurrent) {
                    currentImageData = elements.outputCanvas.toDataURL();
                    isCropped = currentImageData !== originalImageData;
                    croppedImageData = isCropped ? currentImageData : null;
                }
                elements.imageDims.textContent = `${elements.outputCanvas.width}Ã—${elements.outputCanvas.height}px`;
                elements.undoBtn.disabled = history.length === 0;
                elements.revertBtn.disabled = (currentImageData === originalImageData);
            };
            img.src = dataURL;
        }

        // Set the canvas CSS display size to fit within the preview constraints (512x512)
        function setCanvasDisplaySize() {
            try {
                const max = 512;
                const w = elements.outputCanvas.width || 1;
                const h = elements.outputCanvas.height || 1;
                const scale = Math.min(max / w, max / h);
                const displayW = Math.max(1, Math.round(w * scale));
                const displayH = Math.max(1, Math.round(h * scale));
                elements.outputCanvas.style.width = displayW + 'px';
                elements.outputCanvas.style.height = displayH + 'px';
            } catch (e) {
                // ignore
            }
        }

        function undoLast() {
            if (!history.length) return;
            const prev = history.pop();
            restoreFromDataURL(prev, true);
            elements.undoBtn.disabled = history.length === 0;
            elements.revertBtn.disabled = (currentImageData === originalImageData);
            // notification removed
        }

        function revertOriginal() {
            if (!originalImageData) return;
            history = [];
            restoreFromDataURL(originalImageData, true);
            elements.undoBtn.disabled = true;
            elements.revertBtn.disabled = true;
            // notification removed
        }

        function updateCropOverlay() {
            const overlay = elements.cropOverlay;
            const canvas = elements.outputCanvas;
            const container = elements.previewContainer;

            // Get the displayed size of the canvas (affected by CSS)
            const displayedWidth = canvas.offsetWidth;
            const displayedHeight = canvas.offsetHeight;
            
            // Get actual canvas dimensions
            const actualWidth = canvas.width;
            const actualHeight = canvas.height;
            
            // Calculate scale factor
            const scaleX = displayedWidth / actualWidth;
            const scaleY = displayedHeight / actualHeight;

            // Calculate canvas position relative to container
            const canvasLeft = canvas.offsetLeft;
            const canvasTop = canvas.offsetTop;

            // Position the overlay over the crop area
            overlay.style.left = (canvasLeft + cropState.x * scaleX) + 'px';
            overlay.style.top = (canvasTop + cropState.y * scaleY) + 'px';
            overlay.style.width = (cropState.size * scaleX) + 'px';
            overlay.style.height = (cropState.size * scaleY) + 'px';
        }

        function enableCropMode() {
            if (!pixelation) return;

            cropMode = true;
            // keep a backup of the current working image so cancel can restore
            backupBeforeCrop = currentImageData || elements.outputCanvas.toDataURL();

            // Set initial crop size to fit within image
            const maxSize = Math.min(
                elements.outputCanvas.width,
                elements.outputCanvas.height
            );
            cropState.size = Math.min(256, maxSize);
            cropState.x = (elements.outputCanvas.width - cropState.size) / 2;
            cropState.y = (elements.outputCanvas.height - cropState.size) / 2;

            elements.cropSize.value = cropState.size;
            elements.cropX.value = cropState.x;
            elements.cropY.value = cropState.y;

            elements.cropToggleBtn.textContent = 'Disable Crop Tool';
            elements.cropToggleBtn.classList.add('active');
            elements.cropControls.classList.add('active');
            elements.cropOverlay.classList.add('active');

            updateCropOverlay();
            // notification removed
        }

        function disableCropMode(restoreOriginal = true) {
            cropMode = false;
            elements.cropToggleBtn.textContent = 'Enable Crop Tool';
            elements.cropToggleBtn.classList.remove('active');
            elements.cropControls.classList.remove('active');
            elements.cropOverlay.classList.remove('active');
            
            // Restore original image only if canceling (not applying crop)
            // Restore backup (pre-crop) only if canceling (not applying crop)
            if (restoreOriginal && backupBeforeCrop) {
                restoreFromDataURL(backupBeforeCrop, true);
            }
            backupBeforeCrop = null;
            
            cropState.isDragging = false;
            cropState.isResizing = false;
        }

        function applyCrop() {
            if (!pixelation) return;

            if (!currentImageData) return;
            pushHistory();

            // Clamp values based on current canvas size
            const maxX = Math.max(0, elements.outputCanvas.width - cropState.size);
            const maxY = Math.max(0, elements.outputCanvas.height - cropState.size);
            cropState.x = Math.max(0, Math.min(cropState.x, maxX));
            cropState.y = Math.max(0, Math.min(cropState.y, maxY));
            cropState.size = Math.max(10, Math.min(
                cropState.size,
                Math.min(
                    elements.outputCanvas.width - cropState.x,
                    elements.outputCanvas.height - cropState.y
                )
            ));

            // Load current image into an offscreen canvas and crop from it
            const srcImg = new Image();
            srcImg.onload = () => {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = cropState.size;
                tempCanvas.height = cropState.size;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.imageSmoothingEnabled = false;
                // Calculate scale between displayed canvas and source image if necessary
                // Draw the source image at its intrinsic size, then crop region
                // If the source image dimensions differ from outputCanvas, assume coords are based on outputCanvas
                tempCtx.drawImage(
                    srcImg,
                    cropState.x, cropState.y,
                    cropState.size, cropState.size,
                    0, 0,
                    cropState.size, cropState.size
                );

                // Update output canvas with cropped image
                elements.outputCanvas.width = cropState.size;
                elements.outputCanvas.height = cropState.size;
                const ctx = elements.outputCanvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0,0,elements.outputCanvas.width,elements.outputCanvas.height);
                ctx.drawImage(tempCanvas, 0, 0);

                // Store the cropped image data for future operations
                // Update preview display to fit the cropped square
                setCanvasDisplaySize();
                isCropped = true;
                currentImageData = elements.outputCanvas.toDataURL();
                croppedImageData = currentImageData;
                elements.imageDims.textContent = `${cropState.size}Ã—${cropState.size}px`;

                // Disable crop mode without restoring original
                disableCropMode(false);
                elements.undoBtn.disabled = history.length === 0;
                elements.revertBtn.disabled = (currentImageData === originalImageData);
                // notification removed
            };
            srcImg.src = currentImageData;
        }

        // Crop overlay event handlers
        elements.cropOverlay.addEventListener('mousedown', (e) => {
            if (!cropMode) return;

            const handle = e.target.closest('.crop-resize-handle');
            if (handle) {
                cropState.isResizing = true;
                cropState.dragStartX = e.clientX;
                cropState.dragStartY = e.clientY;
            } else {
                cropState.isDragging = true;
                cropState.dragStartX = e.clientX;
                cropState.dragStartY = e.clientY;
                cropState.originalCropX = cropState.x;
                cropState.originalCropY = cropState.y;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (!cropMode) return;

            const canvas = elements.outputCanvas;
            const displayedWidth = canvas.offsetWidth;
            const displayedHeight = canvas.offsetHeight;
            const scaleX = canvas.width / displayedWidth;
            const scaleY = canvas.height / displayedHeight;

            if (cropState.isDragging) {
                const deltaX = (e.clientX - cropState.dragStartX) * scaleX;
                const deltaY = (e.clientY - cropState.dragStartY) * scaleY;

                const maxX = Math.max(0, canvas.width - cropState.size);
                const maxY = Math.max(0, canvas.height - cropState.size);

                cropState.x = Math.max(0, Math.min(cropState.originalCropX + deltaX, maxX));
                cropState.y = Math.max(0, Math.min(cropState.originalCropY + deltaY, maxY));

                elements.cropX.value = Math.round(cropState.x);
                elements.cropY.value = Math.round(cropState.y);

                updateCropOverlay();
            } else if (cropState.isResizing) {
                const deltaX = (e.clientX - cropState.dragStartX) * scaleX;
                const deltaY = (e.clientY - cropState.dragStartY) * scaleY;

                const newSize = Math.max(
                    10,
                    Math.min(
                        cropState.size + Math.max(deltaX, deltaY),
                        Math.min(
                            canvas.width - cropState.x,
                            canvas.height - cropState.y
                        )
                    )
                );

                cropState.size = newSize;
                elements.cropSize.value = Math.round(cropState.size);

                updateCropOverlay();
            }
        });

        document.addEventListener('mouseup', () => {
            cropState.isDragging = false;
            cropState.isResizing = false;
        });

        // Crop controls event handlers
        elements.cropToggleBtn.addEventListener('click', () => {
            if (cropMode) {
                disableCropMode();
            } else {
                enableCropMode();
            }
        });

        elements.cropSize.addEventListener('change', (e) => {
            cropState.size = Math.max(10, parseInt(e.target.value) || 256);
            const maxSize = Math.min(
                elements.outputCanvas.width - cropState.x,
                elements.outputCanvas.height - cropState.y
            );
            cropState.size = Math.min(cropState.size, maxSize);
            elements.cropSize.value = cropState.size;
            updateCropOverlay();
        });

        elements.cropX.addEventListener('change', (e) => {
            cropState.x = Math.max(0, parseInt(e.target.value) || 0);
            const maxX = Math.max(0, elements.outputCanvas.width - cropState.size);
            cropState.x = Math.min(cropState.x, maxX);
            elements.cropX.value = cropState.x;
            updateCropOverlay();
        });

        elements.cropY.addEventListener('change', (e) => {
            cropState.y = Math.max(0, parseInt(e.target.value) || 0);
            const maxY = Math.max(0, elements.outputCanvas.height - cropState.size);
            cropState.y = Math.min(cropState.y, maxY);
            elements.cropY.value = cropState.y;
            updateCropOverlay();
        });

        elements.cropApplyBtn.addEventListener('click', () => {
            applyCrop();
        });

        elements.cropCancelBtn.addEventListener('click', () => {
            disableCropMode(true);
            // notification removed
        });

        // Undo/Revert handlers
        elements.undoBtn.addEventListener('click', () => {
            undoLast();
        });

        elements.revertBtn.addEventListener('click', () => {
            revertOriginal();
        });

        elements.imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                // Store original image data and initialize working state
                originalImageData = event.target.result;
                currentImageData = originalImageData;
                history = [];

                // Draw initial image into canvas
                const img = new Image();
                img.onload = () => {
                    elements.outputCanvas.width = img.naturalWidth;
                    elements.outputCanvas.height = img.naturalHeight;
                    const ctx = elements.outputCanvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    ctx.clearRect(0,0,elements.outputCanvas.width, elements.outputCanvas.height);
                    ctx.drawImage(img, 0, 0);
                    // Ensure preview displays original image preserving aspect ratio within preview constraints
                    setCanvasDisplaySize();

                    // Initialize Pixelation to reference the visible canvas
                    pixelation = new Pixelation(null, elements.outputCanvas);
                    pixelation.setpalette(Pixelation.Common.Palettes[currentPalette]);
                    pixelation.setScale(parseInt(elements.pixelScale.value));

                    elements.placeholder.style.display = 'none';
                    elements.outputCanvas.style.display = 'block';
                    elements.downloadBtn.disabled = false;
                    elements.cropToggleBtn.disabled = false;
                    elements.undoBtn.disabled = true;
                    elements.revertBtn.disabled = true;
                    elements.infoGrid.style.display = 'grid';
                    elements.imageDims.textContent = `${img.naturalWidth}Ã—${img.naturalHeight}px`;
                    
                    // Set palette to Image Default when image loads
                    currentPalette = 'Image Default';
                    document.querySelectorAll('.palette-option').forEach(el => {
                        el.classList.toggle('active', el.textContent === 'Image Default');
                    });
                    elements.paletteInfo.textContent = 'Image Default';
                    // notification removed
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        elements.pixelScale.addEventListener('input', (e) => {
            const value = e.target.value;
            elements.scaleValue.textContent = value;
            if (pixelation) {
                if (!currentImageData) return;
                pushHistory();
                const img = new Image();
                img.onload = () => {
                    elements.outputCanvas.width = img.width;
                    elements.outputCanvas.height = img.height;
                    const ctx = elements.outputCanvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    ctx.clearRect(0,0,elements.outputCanvas.width,elements.outputCanvas.height);
                    ctx.drawImage(img, 0, 0);
                    pixelation.setDrawTo(elements.outputCanvas);
                    pixelation.setScale(parseInt(value));
                    pixelation.pixelate();
                    currentImageData = elements.outputCanvas.toDataURL();
                    // Update preview display size after pixelation
                    setCanvasDisplaySize();
                    isCropped = currentImageData !== originalImageData;
                    croppedImageData = isCropped ? currentImageData : null;
                    elements.undoBtn.disabled = history.length === 0;
                    elements.revertBtn.disabled = (currentImageData === originalImageData);
                };
                img.src = currentImageData;
            }
        });

        elements.outputResolution.addEventListener('change', (e) => {
            if (!pixelation) return;

            const value = e.target.value;
            if (value) {
                const [width, height] = value.split('x').map(Number);
                
                if (!currentImageData) return;
                pushHistory();
                const img = new Image();
                img.onload = () => {
                    elements.outputCanvas.width = width;
                    elements.outputCanvas.height = height;
                    const ctx = elements.outputCanvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    ctx.clearRect(0,0,width,height);
                    ctx.drawImage(img, 0, 0, width, height);
                    currentImageData = elements.outputCanvas.toDataURL();
                    // Update preview display size to fit the new resolution
                    setCanvasDisplaySize();
                    isCropped = currentImageData !== originalImageData;
                    croppedImageData = isCropped ? currentImageData : null;
                    elements.imageDims.textContent = `${width}Ã—${height}px`;
                    elements.undoBtn.disabled = history.length === 0;
                    elements.revertBtn.disabled = (currentImageData === originalImageData);
                    // notification removed
                };
                img.src = currentImageData;
            }
        });

        elements.downloadBtn.addEventListener('click', () => {
            if (!pixelation) return;

                try {
                    pixelation.saveImage();
                    // notification removed
                } catch (error) {
                    console.error(error);
                }
        });

        elements.resetBtn.addEventListener('click', () => {
            // Clear image upload
            elements.imageUpload.value = '';
            
            // Disable crop mode
            if (cropMode) {
                disableCropMode();
            }
            
            // Reset crop state
            isCropped = false;
            croppedImageData = null;
            
            // Reset all controls to defaults
            elements.pixelScale.value = '1';
            elements.scaleValue.textContent = '1';
            elements.outputResolution.value = '';
            
            // Reset palette
            currentPalette = 'Image Default';
            document.querySelectorAll('.palette-option').forEach(el => {
                el.classList.toggle('active', el.textContent === 'Image Default');
            });
            elements.paletteInfo.textContent = 'Image Default';
            
            // Reset UI state
            elements.sourceImage.style.display = 'none';
            elements.outputCanvas.style.display = 'none';
            elements.outputCanvas.style.width = '';
            elements.outputCanvas.style.height = '';
            elements.placeholder.style.display = 'block';
            elements.infoGrid.style.display = 'none';
            
            // Disable action buttons
            elements.downloadBtn.disabled = true;
            elements.cropToggleBtn.disabled = true;
            elements.undoBtn.disabled = true;
            elements.revertBtn.disabled = true;
            
            // Clear pixelation
            pixelation = null;
            history = [];
            currentImageData = null;
            originalImageData = null;
            isCropped = false;
            croppedImageData = null;
            // notification removed
        });

        // Initialize palette grid on page load
        initPaletteGrid();
    </script>
</body>
</html>
